{% extends "base.html" %}

{% block head %}
<!-- MapLibre GL JS -->
<script src="{{ url_for('static', path='/js/maplibre-gl.js') }}"></script>
<link href="{{ url_for('static', path='/css/maplibre-gl.css') }}" rel="stylesheet" />
<style>
    #map {
        height: calc(100vh - 64px);
        width: 100%;
    }

    .maplibregl-popup-content {
        padding: 0;
        border-radius: 12px;
        border: none;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        overflow: hidden;
    }

    /* Custom Scrollbar for side panel if needed */
    .custom-scrollbar::-webkit-scrollbar {
        width: 4px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
        background: transparent;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #cbd5e1;
        border-radius: 20px;
    }
</style>
{% endblock %}

{% block content %}
<div class="relative w-full h-[calc(100vh-64px)]">

    <!-- Map Container -->
    <div id="map" class="absolute inset-0 z-0"></div>

    <!-- Floating Stats (Top Left) -->
    <div class="absolute top-4 left-4 md:top-6 md:left-6 z-10 pointer-events-none">
        <div
            class="pointer-events-auto bg-white/90 backdrop-blur shadow-sm rounded-lg px-3 py-1.5 border border-slate-200">
            <p class="text-xs font-bold text-slate-600 flex items-center gap-2">
                <span class="flex items-center gap-1">
                    <span class="text-slate-800">{{ total_tracks }}</span>
                    <span class="text-[10px] uppercase text-slate-400">traces</span>
                </span>
                <span class="w-px h-3 bg-slate-300 mx-1"></span>
                <span class="flex items-center gap-1">
                    <span class="text-orange-600">{{ total_events }}</span>
                    <span class="text-[10px] uppercase text-slate-400">événements</span>
                </span>
            </p>
        </div>
    </div>

    <!-- Mobile Create Button (Bottom Right) -->
    <div class="absolute bottom-6 right-6 z-20 md:hidden">
        <a href="/upload"
            class="flex items-center justify-center w-14 h-14 bg-brand-600 text-white rounded-full shadow-xl hover:bg-brand-700 transition-transform active:scale-95 shadow-brand-500/40">
            <i class="ph-bold ph-plus text-2xl"></i>
        </a>
    </div>


    <!-- Map Controls (Top Right) -->
    <div class="absolute top-4 right-4 z-10 flex flex-col gap-2">
        <div
            class="bg-white/90 backdrop-blur-md border border-slate-200 rounded-lg shadow-sm p-1.5 flex flex-col gap-1.5">
            <!-- Layers -->
            <button onclick="toggleLayer('heatmap')" id="btn-heatmap"
                class="w-10 h-10 flex items-center justify-center rounded-md transition-colors text-red-600 bg-red-50 ring-1 ring-red-500/20"
                title="Heatmap">
                <i class="ph-fill ph-fire text-lg"></i>
            </button>
            <button onclick="toggleLayer('points')" id="btn-points"
                class="w-10 h-10 flex items-center justify-center rounded-md transition-colors text-emerald-600 bg-emerald-50 ring-1 ring-emerald-500/20"
                title="Traces">
                <i class="ph-fill ph-map-pin text-lg"></i>
            </button>
            <button onclick="toggleLayer('events')" id="btn-events"
                class="w-10 h-10 flex items-center justify-center rounded-md transition-colors text-orange-600 bg-orange-50 ring-1 ring-orange-500/20"
                title="Événements">
                <i class="ph-fill ph-flag-banner text-lg"></i>
            </button>
            <button onclick="toggleLayer('users')" id="btn-users"
                class="w-10 h-10 flex items-center justify-center rounded-md transition-colors text-indigo-600 bg-indigo-50 ring-1 ring-indigo-500/20"
                title="Membres">
                <i class="ph-fill ph-users text-lg"></i>
            </button>

            <div class="h-px bg-slate-200 mx-1 my-0.5"></div>

            <!-- Zoom -->
            <button onclick="zoomIn()"
                class="w-10 h-10 flex items-center justify-center rounded-md hover:bg-slate-100 text-slate-600 transition-colors">
                <i class="ph-bold ph-plus"></i>
            </button>
            <button onclick="zoomOut()"
                class="w-10 h-10 flex items-center justify-center rounded-md hover:bg-slate-100 text-slate-600 transition-colors">
                <i class="ph-bold ph-minus"></i>
            </button>

            <div class="h-px bg-slate-200 mx-1 my-0.5"></div>

            <!-- Type -->
            <button onclick="toggle3D()" id="btn-3d"
                class="w-10 h-10 flex items-center justify-center rounded-md hover:bg-slate-100 text-slate-600 transition-colors font-black text-[10px]"
                title="Basculer 3D">
                3D
            </button>
            <button onclick="toggleSat()" id="btn-sat"
                class="w-10 h-10 flex items-center justify-center rounded-md hover:bg-slate-100 text-slate-600 transition-colors"
                title="Satellite">
                <i class="ph-bold ph-planet text-lg"></i>
            </button>
        </div>
    </div>

    <style>
        /* Custom Switch Styles */
        .toggle-checkbox:checked {
            transform: translateX(100%);
        }

        .toggle-checkbox:checked+.toggle-label {
            background-color: currentColor;
            /* Requires text-color on parent or setting specific bg */
        }

        /* Fix background colors for specific peers since currentColor is tricky here */
        #toggle-heatmap:checked+.toggle-label {
            background-color: #ef4444;
        }

        /* red-500 */
        #toggle-points:checked+.toggle-label {
            background-color: #10b981;
        }

        /* emerald-500 */
        #toggle-events:checked+.toggle-label {
            background-color: #f97316;
        }

        /* orange-500 */
        #toggle-users:checked+.toggle-label {
            background-color: #6366f1;
        }

        /* indigo-500 */
    </style>

    <!-- Loading Indicator (Hidden by default) -->
    <div id="loading-indicator"
        class="hidden absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 bg-white/90 backdrop-blur px-4 py-2 rounded-full shadow-xl flex items-center gap-3">
        <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-brand-600"></div>
        <span class="text-xs font-bold text-slate-700">Chargement de la trace...</span>
    </div>

</div>
{% endblock %}

{% block scripts %}
<script id="tracks-json" type="application/json">
    {{ tracks_json | safe }}
</script>
<script id="users-json" type="application/json">
    {{ users_json | safe }}
</script>
<script id="events-json" type="application/json">
    {{ events_json | safe }}
</script>


<script>
    // Robust Data Parsing
    let tracksRaw = [];
    let usersRaw = [];
    let eventsRaw = [];
    try {
        const tracksEl = document.getElementById('tracks-json');
        const usersEl = document.getElementById('users-json');
        const eventsEl = document.getElementById('events-json');
        if (tracksEl && tracksEl.textContent) tracksRaw = JSON.parse(tracksEl.textContent);
        if (usersEl && usersEl.textContent) usersRaw = JSON.parse(usersEl.textContent);
        if (eventsEl && eventsEl.textContent) eventsRaw = JSON.parse(eventsEl.textContent);
    } catch (e) {
        console.error("Data parsing error:", e);
    }

    // --- Spiderfy Logic Helpers ---

    // 1. Group items by location key (rounded lat/lon)
    function groupItemsByLocation(items, type) {
        const groups = {};
        items.forEach(item => {
            const lat = item.lat || item.location_lat || item.start_lat;
            const lon = item.lon || item.location_lon || item.start_lon;

            if (lat == null || lon == null) return;

            // Use 5 decimals for ~1m precision grouping
            const key = `${lat.toFixed(5)},${lon.toFixed(5)}`;
            if (!groups[key]) {
                groups[key] = { lat: lat, lon: lon, items: [] };
            }
            // Add type for rendering logic
            item._type = type;
            groups[key].items.push(item);
        });
        return groups;
    }

    // 2. Spiderfy Groups
    // Returns { markers: [ {lat, lon, data...} ], legs: [ {from, to} ] }
    function spiderfyGroups(groups) {
        const markers = [];
        const legs = [];

        Object.values(groups).forEach(group => {
            const count = group.items.length;
            const centerLat = group.lat;
            const centerLon = group.lon;

            if (count === 1) {
                // No overlap, keep original
                const item = group.items[0];
                item._displayLat = centerLat;
                item._displayLon = centerLon;
                markers.push(item);
            } else {
                // Spiral/Circle Logic
                const angleStep = (2 * Math.PI) / count;
                const radius = 0.0003; // ~30 meters offset

                group.items.forEach((item, index) => {
                    const angle = index * angleStep;
                    // Simple circle offset
                    const offsetLat = centerLat + (radius * Math.cos(angle) * 0.7); // 0.7 aspect ratio adjustment
                    const offsetLon = centerLon + (radius * Math.sin(angle));

                    item._displayLat = offsetLat;
                    item._displayLon = offsetLon;
                    markers.push(item);

                    // Create leg
                    legs.push({
                        from: [centerLon, centerLat],
                        to: [offsetLon, offsetLat]
                    });
                });
            }
        });

        return { markers, legs };
    }

    // --- Pre-process Data ---

    // Group Users
    const userGroups = groupItemsByLocation(usersRaw || [], 'user');
    const userSpider = spiderfyGroups(userGroups);
    const processedUsers = userSpider.markers;
    const userLegs = userSpider.legs;

    // Group Events
    const eventGroups = groupItemsByLocation(eventsRaw || [], 'event');
    const eventSpider = spiderfyGroups(eventGroups);
    const processedEvents = eventSpider.markers;
    const eventLegs = eventSpider.legs;

    // Tracks? (Only cluster leaves logic for now, or just use tracksRaw if needed)
    // For tracks, we modify separate tracksGeoJSON if we want to "spiderfy" them permanently?
    // User asked for "Zoom In" logic. 
    // Standard approach: Use markers.
    // For now, let's stick to modifying Users and Events as they are Markers.
    // For Tracks, let's see if we can apply same logic.
    // Tracks are points in a GeoJSON source. Modifying the Coordinates in GeoJSON source
    // is equivalent to spiderfying.
    const trackGroups = groupItemsByLocation(tracksRaw || [], 'track');
    const trackSpider = spiderfyGroups(trackGroups);
    // Merge legs
    const allLegs = [...userLegs, ...eventLegs, ...trackSpider.legs];

    // Convert Spiderfied Tracks back to GeoJSON features
    const spiderfiedTracksFeatures = trackSpider.markers.map(t => ({
        "type": "Feature",
        "geometry": {
            "type": "Point",
            "coordinates": [t._displayLon, t._displayLat] // Use computed offset
        },
        "properties": {
            "id": t.id,
            "title": t.title,
            "distance": t.distance_km,
            "elevation": t.elevation_gain,
            "mag": 1
        }
    }));


    // Check MapLibre Availability
    if (typeof maplibregl === 'undefined') {
        console.error("MapLibre GL JS not loaded.");
        document.getElementById('map').innerHTML = '<div class="flex items-center justify-center h-full text-red-500 font-bold">Erreur de chargement de la carte (librairie manquante).</div>';
    } else {

        // Use Pre-processed Tracks for GeoJSON
        const tracksGeoJSON = {
            "type": "FeatureCollection",
            "features": spiderfiedTracksFeatures
        };

        // Legs GeoJSON
        const legsGeoJSON = {
            "type": "FeatureCollection",
            "features": allLegs.map(leg => ({
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [leg.from, leg.to]
                }
            }))
        };

        // Global State
        let hoveredTrackId = null;
        let currentPopup = null;
        let is3D = false;
        let isSat = false;

        // --- Map Initialization ---
        const map = new maplibregl.Map({
            container: 'map',
            style: '/static/style.json',
            center: [2.2137, 46.2276],
            zoom: 5.5,
            pitch: 0,
            bearing: 0,
            antialias: true
        });

        // Geolocation
        if ("geolocation" in navigator) {
            navigator.geolocation.getCurrentPosition(position => {
                const { latitude, longitude } = position.coords;
                map.flyTo({
                    center: [longitude, latitude],
                    zoom: 9,
                    essential: true
                });
            }, error => {
                console.warn("Geolocation access denied or failed:", error);
                fitBoundsToTracks();
            });
        } else {
            fitBoundsToTracks();
        }

        function fitBoundsToTracks() {
            if (tracksRaw && tracksRaw.length > 0) {
                const bounds = new maplibregl.LngLatBounds();
                let hasValidCoords = false;
                tracksRaw.forEach(t => {
                    if (t.start_lat != null && t.start_lon != null) {
                        bounds.extend([t.start_lon, t.start_lat]);
                        hasValidCoords = true;
                    }
                });
                if (hasValidCoords) {
                    map.fitBounds(bounds, { padding: 80, maxZoom: 12, animate: true });
                }
            }
        }

        map.on('load', () => {
            console.log("Map Loaded.");
            try {
                // --- Sources ---

                // 0. Spider Legs Source (Lines)
                map.addSource('spider-legs', {
                    type: 'geojson',
                    data: legsGeoJSON
                });

                // 1. Tracks Source (Points)
                map.addSource('tracks', {
                    type: 'geojson',
                    data: tracksGeoJSON,
                    cluster: true,
                    clusterMaxZoom: 10, // Higher zoom than before to de-cluster earlier
                    clusterRadius: 40 // Smaller radius to split earlier
                });

                // 2. Heatmap Source (Original Data for heatmap correctness?)
                // Actually heatmap relies on density, spiderfying spreads points out.
                // It might slightly diffuse the heatmap but that's acceptable or even desired for precision.
                map.addSource('heatmap-source', {
                    type: 'geojson',
                    data: tracksGeoJSON
                });

                // 3. Hover Track Source
                map.addSource('hover-track', {
                    type: 'geojson',
                    data: { "type": "FeatureCollection", "features": [] }
                });

                // --- Layers ---

                // A. Heatmap Layer
                map.addLayer({
                    id: 'heatmap-layer',
                    type: 'heatmap',
                    source: 'heatmap-source',
                    maxzoom: 15,
                    paint: {
                        'heatmap-weight': ['interpolate', ['linear'], ['get', 'mag'], 0, 0, 6, 1],
                        'heatmap-intensity': ['interpolate', ['linear'], ['zoom'], 0, 1, 9, 3],
                        'heatmap-color': [
                            'interpolate', ['linear'], ['heatmap-density'],
                            0, 'rgba(33,102,172,0)',
                            0.2, 'rgb(103,169,207)',
                            0.4, 'rgb(209,229,240)',
                            0.6, 'rgb(253,219,199)',
                            0.8, 'rgb(239,138,98)',
                            1, 'rgb(178,24,43)'
                        ],
                        'heatmap-radius': ['interpolate', ['linear'], ['zoom'], 0, 2, 9, 20],
                        'heatmap-opacity': ['interpolate', ['linear'], ['zoom'], 7, 1, 12, 0.5],
                    }
                });

                // Z. Spider Legs Layer (Draw these BELOW markers but ABOVE map)
                // Add before heatmap? No, heatmap is base. Add before points.
                map.addLayer({
                    id: 'spider-legs-layer',
                    type: 'line',
                    source: 'spider-legs',
                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                    paint: {
                        'line-color': '#94a3b8', // Slate-400
                        'line-width': 1,
                        'line-opacity': 0.7
                    }
                });


                // B. Track Line Layer (Hover)
                map.addLayer({
                    id: 'hover-track-line',
                    type: 'line',
                    source: 'hover-track',
                    layout: { 'line-join': 'round', 'line-cap': 'round' },
                    paint: {
                        'line-color': '#fc4c02',
                        'line-width': 4,
                        'line-opacity': 0.8
                    }
                });

                // C. Circle Layer (Individual Points)
                map.addLayer({
                    id: 'track-points',
                    type: 'circle',
                    source: 'tracks',
                    filter: ['!', ['has', 'point_count']],
                    paint: {
                        'circle-radius': 5,
                        'circle-color': '#10b981',
                        'circle-stroke-width': 1.5,
                        'circle-stroke-color': '#ffffff',
                        'circle-opacity': 0.9
                    }
                });

                // D. Clusters
                map.addLayer({
                    id: 'clusters',
                    type: 'circle',
                    source: 'tracks',
                    filter: ['has', 'point_count'],
                    paint: {
                        'circle-color': ['step', ['get', 'point_count'], '#51bbd6', 100, '#f1f075', 750, '#f28cb1'],
                        'circle-radius': ['step', ['get', 'point_count'], 20, 100, 30, 750, 40]
                    }
                });

                map.addLayer({
                    id: 'cluster-count',
                    type: 'symbol',
                    source: 'tracks',
                    filter: ['has', 'point_count'],
                    layout: {
                        'text-field': '{point_count_abbreviated}',
                        'text-font': ['Open Sans Semibold'],
                        'text-size': 12
                    }
                });



                // --- Events Markers ---
                // Use processedEvents (spiderfied)
                window.eventMarkers = [];
                if (processedEvents) {
                    processedEvents.forEach(ev => {
                        const el = document.createElement('div');
                        el.className = 'w-8 h-8 rounded-full border-2 border-white shadow-md bg-orange-500 flex items-center justify-center text-white cursor-pointer hover:scale-110 transition-transform';
                        el.innerHTML = '<i class="ph-bold ph-flag-banner"></i>';

                        const popup = new maplibregl.Popup({ offset: 25 }).setHTML(`
                             <div class="p-3 text-center min-w-[140px]">
                                 <h3 class="font-bold text-slate-800 text-sm mb-1 line-clamp-2">${ev.name}</h3>
                                 <p class="text-[10px] text-slate-500 uppercase font-bold tracking-wide mb-2">${ev.location_city || 'Location Unknown'}</p>
                                 <a href="/search?q=${encodeURIComponent(ev.name)}" class="inline-block px-3 py-1.5 bg-orange-50 text-orange-600 text-xs font-bold rounded-lg hover:bg-orange-100 transition-colors">See Event</a>
                             </div>
                         `);

                        const marker = new maplibregl.Marker({ element: el })
                            .setLngLat([ev._displayLon, ev._displayLat]) // Use offset coords
                            .setPopup(popup)
                            .addTo(map);

                        // Keep reference to element for toggling
                        marker.category = 'event';
                        window.eventMarkers.push(marker);
                    });
                }

                // --- Users Markers ---
                window.userMarkers = [];
                if (processedUsers) {
                    processedUsers.forEach(u => {
                        const el = document.createElement('div');
                        el.className = 'w-10 h-10 rounded-full border-2 border-white shadow-md bg-white overflow-hidden cursor-pointer hover:scale-110 transition-transform';
                        if (u.profile_picture) {
                            const img = document.createElement('img');
                            img.src = u.profile_picture;
                            img.className = 'w-full h-full object-cover';
                            el.appendChild(img);
                        } else {
                            // Fallback avatar
                            el.className += ' flex items-center justify-center bg-indigo-500 text-white font-bold text-xs';
                            el.innerText = u.username ? u.username.substring(0, 2).toUpperCase() : '??';
                        }

                        const popup = new maplibregl.Popup({ offset: 25 }).setHTML(`
                             <div class="p-3 text-center min-w-[120px]">
                                  <div class="w-12 h-12 rounded-full overflow-hidden mx-auto mb-2 border border-slate-100">
                                       ${u.profile_picture ? `<img src="${u.profile_picture}" class="w-full h-full object-cover">` : `<div class="w-full h-full bg-indigo-500 flex items-center justify-center text-white text-xs font-bold">${u.username ? u.username.substring(0, 2).toUpperCase() : '?'}</div>`} 
                                  </div>
                                  <h3 class="font-bold text-slate-800 text-sm"><a href="/user/${encodeURIComponent(u.username)}" class="hover:text-brand-600 hover:underline">${u.username}</a></h3>
                                  <p class="text-xs text-slate-500">${u.location_city || 'Member'}</p>
                             </div>
                        `);

                        const m = new maplibregl.Marker({ element: el })
                            .setLngLat([u._displayLon, u._displayLat])
                            .setPopup(popup)
                            .addTo(map);

                        window.userMarkers.push(m);
                    });
                }
            } catch (e) {
                console.error("Map Load Error:", e);
            }

            // ... Interactions same as before ...

            // 1. Hover on Track Points
            map.on('mouseenter', 'track-points', async (e) => {
                map.getCanvas().style.cursor = 'pointer';
                const feature = e.features[0];
                const trackId = feature.properties.id;

                if (currentPopup) { currentPopup.remove(); currentPopup = null; }
                if (hoveredTrackId !== trackId) {
                    map.getSource('hover-track').setData({ "type": "FeatureCollection", "features": [] });
                }

                const coordinates = feature.geometry.coordinates.slice();
                const description = `
                    <div class="px-4 py-3 min-w-[150px]">
                        <h3 class="font-bold text-slate-900 text-sm mb-1 line-clamp-1">${feature.properties.title}</h3>
                        <div class="flex items-center gap-3 text-xs text-slate-500">
                            <span class="font-mono font-bold text-brand-600">${feature.properties.distance.toFixed(1)}km</span>
                            <span>${Math.round(feature.properties.elevation)}m+</span>
                        </div>
                        <p class="text-[10px] text-slate-400 mt-2 italic">Click for details</p>
                    </div>
                `;

                currentPopup = new maplibregl.Popup().setLngLat(coordinates).setHTML(description).addTo(map);

                if (hoveredTrackId !== trackId) {
                    hoveredTrackId = trackId;
                    document.getElementById('loading-indicator').classList.remove('hidden');
                    try {
                        const res = await fetch(`/api/track/${trackId}/geojson`);
                        if (res.ok) {
                            const geojson = await res.json();
                            if (geojson) map.getSource('hover-track').setData(geojson);
                        }
                    } catch (err) { } finally {
                        document.getElementById('loading-indicator').classList.add('hidden');
                    }
                }
            });

            map.on('mouseleave', 'track-points', () => {
                map.getCanvas().style.cursor = '';
            });

            map.on('click', 'clusters', (e) => {
                const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
                const clusterId = features[0].properties.cluster_id;
                map.getSource('tracks').getClusterExpansionZoom(clusterId, (err, zoom) => {
                    if (err) return;
                    map.easeTo({ center: features[0].geometry.coordinates, zoom: zoom });
                });
            });
            map.on('mouseenter', 'clusters', () => map.getCanvas().style.cursor = 'pointer');
            map.on('mouseleave', 'clusters', () => map.getCanvas().style.cursor = '');
            map.on('click', 'track-points', (e) => window.location.href = `/track/${e.features[0].properties.id}`);

        }); // End Load

        // --- Controls Logic ---
        window.zoomIn = function () { if (map) map.zoomIn(); };
        window.zoomOut = function () { if (map) map.zoomOut(); };

        window.toggle3D = function () {
            if (!map) return;
            is3D = !is3D;
            const btn = document.getElementById('btn-3d');
            if (is3D) {
                map.easeTo({ pitch: 60, bearing: -17.6, duration: 1000 });
                if (!map.getSource('terrain')) {
                    map.addSource('terrain', {
                        "type": "raster-dem",
                        "tiles": ["https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png"],
                        "encoding": "terrarium", "tileSize": 256, "maxzoom": 15
                    });
                }
                map.setTerrain({ 'source': 'terrain', 'exaggeration': 1.2 });
                if (btn) {
                    btn.classList.add('text-brand-600', 'bg-brand-50', 'ring-1', 'ring-brand-500/20');
                    btn.classList.remove('hover:bg-slate-100', 'text-slate-600');
                }
            } else {
                map.easeTo({ pitch: 0, bearing: 0, duration: 1000 });
                setTimeout(() => { if (!is3D && map) map.setTerrain(null); }, 1000);
                if (btn) {
                    btn.classList.remove('text-brand-600', 'bg-brand-50', 'ring-1', 'ring-brand-500/20');
                    btn.classList.add('hover:bg-slate-100', 'text-slate-600');
                }
            }
        };

        window.toggleSat = function () {
            if (!map) return;
            isSat = !isSat;
            const btn = document.getElementById('btn-sat');
            if (isSat) {
                if (!map.getLayer('satellite-layer')) {
                    const beforeId = map.getLayer('heatmap-layer') ? 'heatmap-layer' : null;
                    map.addLayer({
                        'id': 'satellite-layer', 'type': 'raster',
                        'source': {
                            'type': 'raster', 'tiles': ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
                            'tileSize': 256
                        }, 'paint': {}
                    }, beforeId);
                } else {
                    map.setLayoutProperty('satellite-layer', 'visibility', 'visible');
                }
                if (btn) {
                    btn.classList.add('text-brand-600', 'bg-brand-50', 'ring-1', 'ring-brand-500/20');
                    btn.classList.remove('hover:bg-slate-100', 'text-slate-600');
                }
            } else {
                if (map.getLayer('satellite-layer')) map.setLayoutProperty('satellite-layer', 'visibility', 'none');
                if (btn) {
                    btn.classList.remove('text-brand-600', 'bg-brand-50', 'ring-1', 'ring-brand-500/20');
                    btn.classList.add('hover:bg-slate-100', 'text-slate-600');
                }
            }
        };

        // Fixed Toggle Logic
        // Uses dataset or robust class checking
        window.toggleLayer = function (layerType) {
            if (!map) return;
            const btn = document.getElementById(`btn-${layerType}`);
            // Check state via class presence of active style
            // Better: use a data attribute for state, but class check is fine if consistent
            let isActive = false;

            // Helper to check active state
            const isBtnActive = (b, colorClass) => b.classList.contains(colorClass);

            switch (layerType) {
                case 'heatmap':
                    if (map.getLayer('heatmap-layer')) {
                        const vis = map.getLayoutProperty('heatmap-layer', 'visibility');
                        isActive = (vis !== 'none'); // Current state
                        // Toggle
                        isActive = !isActive;
                        map.setLayoutProperty('heatmap-layer', 'visibility', isActive ? 'visible' : 'none');
                        updateBtnState(btn, isActive, 'red');
                    }
                    break;
                case 'points':
                    if (map.getLayer('track-points')) {
                        const vis = map.getLayoutProperty('track-points', 'visibility');
                        isActive = (vis !== 'none');
                        isActive = !isActive;
                        const v = isActive ? 'visible' : 'none';
                        map.setLayoutProperty('track-points', 'visibility', v);
                        if (map.getLayer('clusters')) map.setLayoutProperty('clusters', 'visibility', v);
                        if (map.getLayer('cluster-count')) map.setLayoutProperty('cluster-count', 'visibility', v);
                        // Also toggle legs and their spider points if we treat tracks as markers? 
                        // Current logic modified tracksGeoJSON for tracks points, so they hide with 'track-points'.
                        // However, legs are in 'spider-legs-layer'.
                        if (map.getLayer('spider-legs-layer')) map.setLayoutProperty('spider-legs-layer', 'visibility', v);

                        updateBtnState(btn, isActive, 'emerald');
                    }
                    break;
                case 'events':
                    // Check if currently active based on button
                    isActive = isBtnActive(btn, 'bg-orange-50');
                    isActive = !isActive; // Toggle

                    if (window.eventMarkers) {
                        window.eventMarkers.forEach(m => {
                            const el = m.getElement();
                            if (isActive) el.classList.remove('hidden');
                            else el.classList.add('hidden');
                        });
                    }
                    updateBtnState(btn, isActive, 'orange');
                    break;
                case 'users':
                    isActive = isBtnActive(btn, 'bg-indigo-50');
                    isActive = !isActive;

                    if (window.userMarkers) {
                        window.userMarkers.forEach(m => {
                            const el = m.getElement();
                            if (isActive) el.classList.remove('hidden');
                            else el.classList.add('hidden');
                        });
                    }
                    updateBtnState(btn, isActive, 'indigo');
                    break;
            }
        };

        function updateBtnState(btn, active, color) {
            const classes = [`text-${color}-600`, `bg-${color}-50`, 'ring-1', `ring-${color}-500/20`];
            if (active) {
                btn.classList.remove('text-slate-600', 'hover:bg-slate-100');
                btn.classList.add(...classes);
            } else {
                btn.classList.remove(...classes);
                btn.classList.add('text-slate-600', 'hover:bg-slate-100');
            }
        }
    }
</script>
{% endblock %}